{"ast":null,"code":"import _classCallCheck from \"C:\\\\todo-app\\\\frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"C:\\\\todo-app\\\\frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport * as i0 from '@angular/core';\nimport { NgZone, Pipe, Directive, Input, NgModule } from '@angular/core';\nimport { Subject, EMPTY, isObservable, from } from 'rxjs';\nimport { distinctUntilChanged, switchMap, tap, catchError } from 'rxjs/operators';\n/**\n * class CdAware\n *\n * @description\n * This abstract class holds all the shared logic for the push pipe and the let directive\n * responsible for change detection\n * If you extend this class you need to implement how the update of the rendered value happens.\n * Also custom behaviour is something you need to implement in the extending class\n */\n\nfunction createCdAware(cfg) {\n  var potentialObservablesSubject = new Subject();\n  var observablesFromTemplate$ = potentialObservablesSubject.pipe(distinctUntilChanged());\n  var rendering$ = observablesFromTemplate$.pipe( // Compose the observables from the template and the strategy\n  switchMap(function (observable$) {\n    // If the passed observable is:\n    // - undefined - No value set\n    // - null - null passed directly or no value set over `async` pipe\n    if (observable$ == null) {\n      // Update the value to render_creator with null/undefined\n      cfg.updateViewContextObserver.next(observable$); // Render the view\n\n      cfg.render(); // Stop further processing\n\n      return EMPTY;\n    }\n\n    var ob$ = isObservable(observable$) ? observable$ : from(observable$); // If a new Observable arrives, reset the value to render_creator\n    // We do this because we don't know when the next value arrives and want to get rid of the old value\n\n    cfg.resetContextObserver.next();\n    cfg.render();\n    return ob$.pipe(distinctUntilChanged(), tap(cfg.updateViewContextObserver), tap(function () {\n      return cfg.render();\n    }), catchError(function (e) {\n      cfg.errorHandler.handleError(e);\n      return EMPTY;\n    }));\n  }));\n  return {\n    nextPotentialObservable: function nextPotentialObservable(value) {\n      potentialObservablesSubject.next(value);\n    },\n    subscribe: function subscribe() {\n      return rendering$.subscribe();\n    }\n  };\n}\n/**\n * @description\n *\n * Determines if the application uses `NgZone` or `NgNoopZone` as ngZone service instance.\n *\n * The function can be just imported and used everywhere.\n *\n * ```ts\n * import { hasZone } from `utils/has-zone`;\n *\n * console.log(hasZone());\n * ```\n */\n\n\nfunction hasZone(z) {\n  return z instanceof NgZone;\n}\n\nfunction createRender(config) {\n  function render() {\n    if (hasZone(config.ngZone)) {\n      config.cdRef.markForCheck();\n    } else {\n      config.cdRef.detectChanges();\n    }\n  }\n\n  return render;\n}\n/**\n * @ngModule ReactiveComponentModule\n *\n * @description\n *\n * The `ngrxPush` pipe serves as a drop-in replacement for the `async` pipe.\n * It contains intelligent handling of change detection to enable us\n * running in zone-full as well as zone-less mode without any changes to the code.\n *\n * The current way of binding an observable to the view looks like that:\n *  ```html\n *  {{observable$ | async}}\n * <ng-container *ngIf=\"observable$ | async as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | async\"></component>\n * ```\n *\n * The problem is `async` pipe just marks the component and all its ancestors as dirty.\n * It needs zone.js microtask queue to exhaust until `ApplicationRef.tick` is called to render_creator all dirty marked\n *     components.\n *\n * Heavy dynamic and interactive UIs suffer from zones change detection a lot and can\n * lean to bad performance or even unusable applications, but the `async` pipe does not work in zone-less mode.\n *\n * `ngrxPush` pipe solves that problem.\n *\n * Included Features:\n *  - Take observables or promises, retrieve their values and render_creator the value to the template\n *  - Handling null and undefined values in a clean unified/structured way\n *  - Triggers change-detection differently if `zone.js` is present or not (`detectChanges` or `markForCheck`)\n *  - Distinct same values in a row to increase performance\n *  - Coalescing of change detection calls to boost performance\n *\n * @usageNotes\n *\n * `ngrxPush` pipe solves that problem. It can be used like shown here:\n * ```html\n * {{observable$ | ngrxPush}}\n * <ng-container *ngIf=\"observable$ | ngrxPush as o\">{{o}}</ng-container>\n * <component [value]=\"observable$ | ngrxPush\"></component>\n * ```\n *\n * @publicApi\n */\n\n\nvar PushPipe = /*#__PURE__*/(function () {\n  var PushPipe = /*#__PURE__*/function () {\n    function PushPipe(cdRef, ngZone, errorHandler) {\n      var _this = this;\n\n      _classCallCheck(this, PushPipe);\n\n      this.resetContextObserver = {\n        next: function next() {\n          return _this.renderedValue = undefined;\n        }\n      };\n      this.updateViewContextObserver = {\n        next: function next(value) {\n          return _this.renderedValue = value;\n        }\n      };\n      this.cdAware = createCdAware({\n        render: createRender({\n          cdRef: cdRef,\n          ngZone: ngZone\n        }),\n        updateViewContextObserver: this.updateViewContextObserver,\n        resetContextObserver: this.resetContextObserver,\n        errorHandler: errorHandler\n      });\n      this.subscription = this.cdAware.subscribe({});\n    }\n\n    _createClass(PushPipe, [{\n      key: \"transform\",\n      value: function transform(potentialObservable) {\n        this.cdAware.nextPotentialObservable(potentialObservable);\n        return this.renderedValue;\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n    }]);\n\n    return PushPipe;\n  }();\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  PushPipe.ɵfac = function PushPipe_Factory(t) {\n    return new (t || PushPipe)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16), i0.ɵɵdirectiveInject(i0.NgZone, 16), i0.ɵɵdirectiveInject(i0.ErrorHandler, 16));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  PushPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"ngrxPush\",\n    type: PushPipe,\n    pure: false\n  });\n  return PushPipe;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * @ngModule ReactiveComponentModule\n *\n * @description\n *\n * The `*ngrxLet` directive serves a convenient way of binding observables to a view context (a dom element scope).\n * It also helps with several internal processing under the hood.\n *\n * The current way of binding an observable to the view looks like that:\n * ```html\n * <ng-container *ngIf=\"observableNumber$ | async as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * <app-number-special [number]=\"n\">\n * </app-number-special>\n * </ng-container>\n *  ```\n *\n *  The problem is `*ngIf` is also interfering with rendering and in case of a `0` the component would be hidden\n *\n * Included Features:\n * - binding is always present. (`*ngIf=\"truthy$ | async\"`)\n * - it takes away the multiple usages of the `async` or `ngrxPush` pipe\n * - a unified/structured way of handling null and undefined\n * - triggers change-detection differently if `zone.js` is present or not (`ChangeDetectorRef.detectChanges` or `ChangeDetectorRef.markForCheck`)\n * - triggers change-detection differently if ViewEngine or Ivy is present (`ChangeDetectorRef.detectChanges` or `ɵdetectChanges`)\n * - distinct same values in a row (distinctUntilChanged operator)\n *\n * @usageNotes\n *\n * The `*ngrxLet` directive take over several things and makes it more convenient and save to work with streams in the template\n * `<ng-container *ngrxLet=\"observableNumber$ as c\"></ng-container>`\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$ as n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n *\n * <ng-container *ngrxLet=\"observableNumber$; let n\">\n * <app-number [number]=\"n\">\n * </app-number>\n * </ng-container>\n * ```\n *\n * In addition to that it provides us information from the whole observable context.\n * We can track the observables:\n * - next value\n * - error value\n * - complete state\n *\n * ```html\n * <ng-container *ngrxLet=\"observableNumber$; let n; let e = $error, let c = $complete\">\n * <app-number [number]=\"n\"  *ngIf=\"!e && !c\">\n * </app-number>\n * <ng-container *ngIf=\"e\">\n * There is an error: {{e}}\n * </ng-container>\n * <ng-container *ngIf=\"c\">\n * Observable completed: {{c}}\n * </ng-container>\n * </ng-container>\n * ```\n *\n * @publicApi\n */\n\n\nvar LetDirective = /*#__PURE__*/(function () {\n  var LetDirective = /*#__PURE__*/function () {\n    function LetDirective(cdRef, ngZone, templateRef, viewContainerRef, errorHandler) {\n      var _this2 = this;\n\n      _classCallCheck(this, LetDirective);\n\n      this.templateRef = templateRef;\n      this.viewContainerRef = viewContainerRef;\n      this.isEmbeddedViewCreated = false;\n      this.viewContext = {\n        $implicit: undefined,\n        ngrxLet: undefined,\n        $error: false,\n        $complete: false\n      };\n      this.resetContextObserver = {\n        next: function next() {\n          // if not initialized no need to set undefined\n          if (_this2.isEmbeddedViewCreated) {\n            _this2.viewContext.$implicit = undefined;\n            _this2.viewContext.ngrxLet = undefined;\n            _this2.viewContext.$error = false;\n            _this2.viewContext.$complete = false;\n          }\n        }\n      };\n      this.updateViewContextObserver = {\n        next: function next(value) {\n          _this2.viewContext.$implicit = value;\n          _this2.viewContext.ngrxLet = value; // to have init lazy\n\n          if (!_this2.isEmbeddedViewCreated) {\n            _this2.createEmbeddedView();\n          }\n        },\n        error: function error(_error) {\n          _this2.viewContext.$error = true; // to have init lazy\n\n          if (!_this2.isEmbeddedViewCreated) {\n            _this2.createEmbeddedView();\n          }\n        },\n        complete: function complete() {\n          _this2.viewContext.$complete = true; // to have init lazy\n\n          if (!_this2.isEmbeddedViewCreated) {\n            _this2.createEmbeddedView();\n          }\n        }\n      };\n      this.cdAware = createCdAware({\n        render: createRender({\n          cdRef: cdRef,\n          ngZone: ngZone\n        }),\n        resetContextObserver: this.resetContextObserver,\n        updateViewContextObserver: this.updateViewContextObserver,\n        errorHandler: errorHandler\n      });\n      this.subscription = this.cdAware.subscribe({});\n    }\n\n    _createClass(LetDirective, [{\n      key: \"ngrxLet\",\n      set: function set(potentialObservable) {\n        this.cdAware.nextPotentialObservable(potentialObservable);\n      }\n    }, {\n      key: \"createEmbeddedView\",\n      value: function createEmbeddedView() {\n        this.isEmbeddedViewCreated = true;\n        this.viewContainerRef.createEmbeddedView(this.templateRef, this.viewContext);\n      }\n    }, {\n      key: \"ngOnDestroy\",\n      value: function ngOnDestroy() {\n        this.subscription.unsubscribe();\n      }\n    }], [{\n      key: \"ngTemplateContextGuard\",\n      value: function ngTemplateContextGuard(dir, ctx) {\n        return true;\n      }\n    }]);\n\n    return LetDirective;\n  }();\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  LetDirective.ɵfac = function LetDirective_Factory(t) {\n    return new (t || LetDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ErrorHandler));\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  LetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LetDirective,\n    selectors: [[\"\", \"ngrxLet\", \"\"]],\n    inputs: {\n      ngrxLet: \"ngrxLet\"\n    }\n  });\n  return LetDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar DECLARATIONS = [LetDirective, PushPipe];\nvar EXPORTS = [DECLARATIONS];\nvar ReactiveComponentModule = /*#__PURE__*/(function () {\n  var ReactiveComponentModule = /*#__PURE__*/_createClass(function ReactiveComponentModule() {\n    _classCallCheck(this, ReactiveComponentModule);\n  });\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  ReactiveComponentModule.ɵfac = function ReactiveComponentModule_Factory(t) {\n    return new (t || ReactiveComponentModule)();\n  };\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  ReactiveComponentModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ReactiveComponentModule\n  });\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n  ReactiveComponentModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ReactiveComponentModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { LetDirective, PushPipe, ReactiveComponentModule };","map":null,"metadata":{},"sourceType":"module"}